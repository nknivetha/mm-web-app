<!DOCTYPE html>

<html>
<head>

    <title>View and Edit</title>
</head>

<body>
    <!-- Setup Firebase -->
    <script src="https://www.gstatic.com/firebasejs/5.8.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/5.8.1/firebase-database.js"></script>
    <script src="https://www.gstatic.com/firebasejs/5.8.1/firebase-auth.js"></script>

    <script>
        var config = {
            apiKey: "AIzaSyDkJap-l-nEEa8_Up_fRyBKadFLO8PzKQM",
            authDomain: "miraclemessages-v2.firebaseapp.com",
            databaseURL: "https://miraclemessages-v2.firebaseio.com",
            projectId: "miraclemessages-v2",
            storageBucket: "miraclemessages-v2.appspot.com",
            messagingSenderId: "669586730683"
        };
        app = firebase.initializeApp(config);
    </script>

    <!-- Import headerToColl (dictionary), getURLParams, formatWords,
         escapeSingleQuotes, appendHTML, addFromRef, getData -->
    <script src='utils/database.js'></script>

    <script>
        // Initialize Firebase
        const db = firebase.database();
        const URLParams = getURLParams();
        const caseID = URLParams["caseID"];
        const isAdmin = (URLParams["isAdmin"] === 'true');

        // Setup a dictionary for the unedited data so that when data is saved,
        // only changed data will be saved.
        let originalData = {};

        // Allow each input field to be edited.
        function enableEdit() {
            // Get a list of all the input elements.
            let inputs = document.getElementsByTagName("input");

            for (let i = 0; i < inputs.length; i++) {
                // Make each input editable.
                inputs[i].readOnly = false;
            }
        }

        // Disallow edits of input fields.
        function disableEdit(fields) {
            for (let i = 0; i < fields.length; i++) {
                fields[i].readOnly = true;
            }
        }

        // Find data that was altered.
        function getAlteredData(fields) {
            let alteredData = {};

            console.log('get altered data: original data:', originalData);

            for (let i = 0; i < fields.length; i++) {
                // Find the firebase collection that this field is in.
                parentColl = headerToColl[fields[i].parentNode.id];

                // Check if this field was changed.
                let path = parentColl + '/' + fields[i].id;

                if (originalData[path] != fields[i].value) {
                    // This field was changed.
                    alteredData[path] = fields[i].value;
                }
            }

            console.log('get altered data: altered data:', alteredData);
            return alteredData;
        }

        // Write altered data to the database.
        function writeData(fields) {
            // Find the altered data.
            const alteredData = getAlteredData(fields);

            // Collect the current date time
            var today = new Date;
            var sec = today.getSeconds();
            var min = today.getMinutes();
            var hr = today.getHours();
            var day = today.getDate();
            var month = today.getMonth() + 1;
            var year = today.getFullYear();

            var dateTime = hr + ':' + min + ':' + sec + '::' + month + '/' + day + '/' + year;

            db.ref('proposed/id').once('value').then(function(snapshot) {
                // Get the next proposal ID. The '+ 1 - 1' is to convert null
                // to 0 becuase if the 'proposed' collection is not in the
                // database, then 'proposed/id' will be null.
                proposalID = snapshot.val() + 1 - 1;

                // Update the fields.
                for (let key in alteredData) {
                    // The key is in the form 'cases/id/field', so we have to
                    // extract the path and field.
                    const pathEnd = key.lastIndexOf('/');
                    const path = key.substring(0, pathEnd);
                    const field = key.substring(pathEnd + 1);

                    let newData = {};
                    newData[field] = alteredData[key];

                    // If a nonadmin updates case status info, add it to the
                    // 'proposed' queue for an admin to approve it.
                    if (isAdmin || !path.startsWith('cases')) {
                        // Write the data directly to the database.
                        // and store a copy in the audit log (with the
                        // current dateTime stored as well)
                        db.ref(path).update(newData);
                        newData['dateTime'] = dateTime;
                        db.ref('audits/' + path).set(newData);
                    }
                    else {
                        // Enqueue the proposed edit to be approved by admin.
                        // Include the dateTime (should be removed when
                        // storing the data in the actual collections tho).
                        newData['dateTime'] = dateTime;
                        db.ref('proposed/' + proposalID + '/' + path).set(newData);
                        db.ref('proposed/' + proposalID).update({caseID: caseID});

                        // Update the proposal ID.
                        proposalID += 1
                        db.ref('proposed').update({id: proposalID});
                    }
                }

                // Update the originalData dictionary so that if you change field A
                // and then save, then change field A back to its original value
                // and save again, the final value for A in the database will be
                // the original.
                for (let key in alteredData) {
                    originalData[key] = alteredData[key];
                }
            });
        }

        // Disable input field editing and write data to the database.
        function save() {
            // Get a list of all the input elements.
            let fields = document.getElementsByTagName("input");

            // Disable editing and save changes to the database.
            disableEdit(fields);
            writeData(fields);
            alert("Successfully saved changes");
        }

        // Load a case.
        getData(caseID, originalData);
    </script>

    <div id='Case Overview'></div>
    <div id='Client'></div>
    <div id='Loved Ones'></div>
    <div id='Notes'></div>
    <div id='Records'></div>
    <div id='Volunteer'></div>

    <button type="button" id="edit" onclick=enableEdit()>Edit</button>
    <button type="button" id="save" onclick=save()>Save</button>
</body>
</html>
